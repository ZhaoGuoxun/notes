## 邂逅数据结构和算法

### 什么是数据结构

1. 在计算机中，存储和组织数据的方式

   如何以高效的方式组织和存储呢？

   使得两个相关操作方便实现：

   ​		新书如何插入？

   ​		怎么找到某本指定的书？

2. 常见数据结构：

   ​	**数组 栈 链表 图 散列表 堆 队列 树**

   ​	每一种数据结构都有其对应的应用场景，不同的数据结构不同操作性能是不同的

***了解真相，才能获得真正的自由。***

### 什么是算法 algorithm

1. 数据结构的实现，离不开算法
2. 解决问题的办法/步骤逻辑

### 生活中的数据结构

1. 图书馆图书的摆放
2. 快递员的快递
3. 找出线缆出问题的地方

## 数组的补充

1. JS的数组其实就是API的调用

2. 普通语言的数组封装

   ​	常见语言的数组不能存放不同的数据类型

   ​	数组长度不能自动改变

   ​	从中间插入删除操作性能比较低

3. 通过下标值获取修改元素时效率很高

4. 数组的优势和不足

   数组进行插入操作时，效率比较低

   数组进行查找：

   ​	*如果基于索引查找，效率比较高

   ​	*如果基于内容查找，效率不是很高

   数组进行删除时，效率也不高

## 栈结构 Stack

1. 数组是一种线性结构，可以任意的插入删除元素；但有些时候为了实现某些功能需要对这种任意性加以限制
2. 栈只能在一端添加删除元素  后进先出（LIFO）
3. 程序中使用栈的技术
   + 函数调用栈

4. 面试题目
   + 一组元素顺序进栈，哪一种不是合法的出栈序列？

5. 栈结构的实现
   + 基于数组实现
   + 基于链表实现

6. 应用场景
   + 十进制转二进制
   + 中缀表达式转后缀表达式

## 队列结构 Queue

1. 队列也是一种受限的线性表，先进先出（FIFO）

   只允许在表的前端进行删除操作，在表的后端进行插入操作

2. 生活中的队列结构
   + 排队
   + 结账
   + 打印队列
   + 线程队列

3. 队列的实现

   + 基于数组实现
   + 基于链表实现  性能较数组高

4. 面试题

   + 击鼓传花

     > n个人，开始数数，数到某一个数，这个人出列，继续往下数，数到最后一个人获胜。

## 优先级队列

1. 每个元素不再只是一个数据，而且包含数据的优先级
2. 根据优先级添加到正确的位置
3. 应用
   + 急诊科
   + 头等舱
   + 每个线程处理的任务重要性不同

## 链表  LinkedList

1. 数组存放是连续的内存空间，并且大小是固定的；在开头或中间位置插入数据时成本很高，需要大量位移操作。

2. 链表每个元素由一个存储元素本身的节点和一个指向下一个元素的引用；

   内存空间不必连续，实现内存的动态管理；

   链表没有固定大小，可以无限延伸；

   在插入和删除数据时，时间复杂度可以达到O(1);

   链表访问任何一个位置的元素，都要从头开始


## 双向链表

1. 一个节点既有向前连接的引用，也有一个向后连接的引用；

   一个head指针和一个tail指针

2. 举例

   文本编辑器：每行都用一个String对象存在链表的一个节点中

## 集合

1. 集合比较常见的实现方式是哈希表

   无序的，不能重复的

## 字典

1. 数组 集合 字典几乎是编程语言都会默认提供的数据类型

   存储键值对

    特点：一一对应，key不可以重复，value可以重复，key是无序的

2. 很多编程语言比如java中对字典和对象的区分比较明显，对象通常是一种在编译期就确定下来的结构，不可以动态的添加和删除属性，而字典通常会使用类似于哈希表的数据结构去实现一种可以动态的添加数据的结构；

   但是在js中，似乎对象本身就是一种字典，所以在早期的js中没有这种数据类型。

## 哈希表

1. 基于数组实现的

   优势：提供快速的插入删除查询数据，时间复杂度`O(1)`，只需要几个机器指令就可以实现

   不足：数组没有顺序，key不允许重复

2. 哈希表的结构就是数组，神奇之处在于对下标值的一种变换（哈希函数），通过哈希函数获取到HashCode

3. 举例

   公司人员信息 电话簿 单词本

4. 编码：

   1. Ebcdic 英文字母不是连续的
   2. ASCII  美国 一个字节 128
   3. ISO-8859-1  西方国家 一个字节 256
   4. GBXX
      1. GB2312 两个字节  常用汉字 ≈6763 个
      2. GBK 两个字节
      3. GB18030

   5. Unicode
      1. UTF-8 可变长度字符编码
      2. UTF-16 2个字节
      3. UTF-32 4个字节，浪费资源

5. 哈希函数：

   1. 数字相加 对应的字母的数字相加

   2. 幂的连乘 

      > cats  3\*27³ +1\*27²+20\*27+17
      >
      > 数组过大，空间浪费

   3. 哈希化   取余操作

   5. **快速的计算**：霍纳法则（秦九韶算法）

      多项式提取：时间复杂度由O(N²)降到了O(N)

   6. **均匀的分布**：质数的使用：
   哈希表的长度
      N次幂的底数
   
6. 哈希概念

   ​    **将大数字转化为数组范围内的下标这个过程叫哈希化**

   ​	**将单词转成大数字，大数字进行哈希化的代码叫做哈希函数**

   ​	**最终将数据插入到这个数组，就是哈希表**

7. 冲突 哈希化后产生冲突如何解决

   **链地址法（拉链法）**

   > 当产生冲突后，每个位置都存储一个链表或者数组（需要线性查找，而且数据量也不大，所以都可以使用）

   **开放地址法**

    > 寻找空白的单元格
    >
    > 线性探测： 线性查找，如果聚集（一连串填充单元），会影响哈希表的性能
    >
    > 二次探测：对探测步长进行优化，避免聚集带来的影响；
    >
    > 再哈希法：把关键字用另外一个哈希函数再做一次哈希化，用哈希化的结果作为步长
    >
    > stepSize = constant - (key % constant)	//constant是质数

8. 哈希化的效率

   ```txt
   1.执行插入和搜索操作效率是非常高的
   2.如果产生冲突，依赖于探测长度
   3.平均探测长度以及平均存取时间取决于填装因子
   装填因子 = 总数据项 / 哈希表长度
   链地址法相对于开放地址法效率更好一点，不会因为添加了某元素后性能急剧下降（指数增长），链地址（线性增长），如java中Hashmap使用的就是链地址法
   ```

9. Java里的hashmap
   采用的是链地址法，hashmap的长度为2的整数幂
   hashmap为了提高效率，采用了位运算的方式

10. 哈希表扩容
    长度修改后，所有元素的位置都要进行重新计算，这个过程是必须的
    loadFactor > 0.75 的时候进行扩容
    loadFactor < 0.25 的时候进行减小
    
11. 哈希表的缺点：

    + 空间利用率不高
    + 元素无序，不能按照固定的顺序来遍历
    + 不能快速找出哈希表中的最大值或者最小值

## 树结构

1. 树的抽象，可以抽象到很多生活中的场景:

   公司的组织架构

2. 树的优点：

   空间利用率高，有序，较高的效率；树结构是非线性的，可以一对多的关系；比如文件的目录结构
   
3. 术语：
   度：子节点的个数
   叶结点：度为0的节点

4. 表示法：
   儿子-兄弟表示法：所有的树本质都可以用二叉树来模拟
   二叉树的存储： 数组和链表（最常见）

5. 二叉树：
   每个节点最多有两个子节点
   一个二叉树第i层最大节点数： 2^(i - 1), i>=1
   深度为k的二叉树最大节点总数： 2^k - 1, k>=1
   任何非空二叉树T, n0 表示叶子节点的个数，n2 为度为2的非叶结点的个数，有 n0 = n2 + 1；

   1. 完美二叉树（满二叉树）
   2. 完全二叉树：除最后一层，其他层的节点个数都达到最大，最后一层从左向右的节点连续存在，且只缺右侧若干节点

   